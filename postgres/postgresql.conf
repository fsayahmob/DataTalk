# =============================================================================
# PostgreSQL 16 - Configuration Optimisée pour DataTalk
# =============================================================================
# Optimisé par: Configuration DBA Google-style
# Objectif: Haute concurrence, écriture intensive, pas de locks
# =============================================================================

# -----------------------------------------------------------------------------
# CONNEXIONS
# -----------------------------------------------------------------------------
# Max connections: API (pool 20) + Worker (pool 10) + Admin (5) + Marge (15)
max_connections = 50
superuser_reserved_connections = 3

# -----------------------------------------------------------------------------
# MÉMOIRE (optimisé pour Mac puissant - container 2GB)
# -----------------------------------------------------------------------------
# shared_buffers: 25% de la RAM disponible (container 2GB → 512MB)
shared_buffers = 512MB

# effective_cache_size: 75% de la RAM (ce que l'OS peut cacher)
effective_cache_size = 1536MB

# work_mem: mémoire par opération de tri/hash (augmenté pour analytics)
# Attention: multiplié par (max_connections * opérations parallèles)
work_mem = 32MB

# maintenance_work_mem: pour VACUUM, CREATE INDEX, etc.
maintenance_work_mem = 256MB

# -----------------------------------------------------------------------------
# WAL (Write-Ahead Log) - CRITIQUE POUR PERFORMANCE ÉCRITURE
# -----------------------------------------------------------------------------
# wal_level: minimal pour perf max (pas de réplication pour l'instant)
wal_level = minimal
max_wal_senders = 0

# wal_buffers: buffer pour les écritures WAL (auto = 3% de shared_buffers)
wal_buffers = 4MB

# checkpoint_completion_target: étaler les checkpoints (réduit les pics I/O)
checkpoint_completion_target = 0.9

# checkpoint_timeout: moins fréquent = moins d'I/O
checkpoint_timeout = 10min

# max_wal_size: plus de WAL avant checkpoint forcé
max_wal_size = 1GB
min_wal_size = 256MB

# -----------------------------------------------------------------------------
# SYNCHRONISATION - COMPROMIS PERF/DURABILITÉ
# -----------------------------------------------------------------------------
# synchronous_commit: off = commit plus rapide (risque: perte 3 dernières tx si crash)
# Pour un SaaS non-financier, c'est acceptable
synchronous_commit = off

# fsync: garder ON (sinon corruption si crash)
fsync = on

# full_page_writes: garder ON pour éviter corruption
full_page_writes = on

# -----------------------------------------------------------------------------
# CONCURRENCE & LOCKS - ÉVITER LES DEADLOCKS
# -----------------------------------------------------------------------------
# deadlock_timeout: temps avant détection de deadlock
deadlock_timeout = 1s

# lock_timeout: timeout pour acquisition de lock (évite les attentes infinies)
lock_timeout = 10s

# statement_timeout: évite les requêtes infinies
statement_timeout = 60s

# idle_in_transaction_session_timeout: tue les sessions inactives dans une transaction
idle_in_transaction_session_timeout = 5min

# -----------------------------------------------------------------------------
# MVCC (Multi-Version Concurrency Control)
# -----------------------------------------------------------------------------
# PostgreSQL utilise MVCC par défaut - pas de locks en lecture!
# Ces paramètres optimisent le garbage collection des anciennes versions

# autovacuum plus agressif pour nettoyer les dead tuples
autovacuum = on
autovacuum_max_workers = 3
autovacuum_naptime = 30s
autovacuum_vacuum_threshold = 50
autovacuum_vacuum_scale_factor = 0.1
autovacuum_analyze_threshold = 50
autovacuum_analyze_scale_factor = 0.05

# vacuum_cost_* : limiter l'impact I/O du vacuum
vacuum_cost_delay = 2ms
vacuum_cost_limit = 1000

# -----------------------------------------------------------------------------
# QUERY PLANNER
# -----------------------------------------------------------------------------
# random_page_cost: réduit pour SSD (défaut 4.0 pour HDD)
random_page_cost = 1.1

# effective_io_concurrency: augmenté pour SSD
effective_io_concurrency = 200

# parallel query settings
max_parallel_workers_per_gather = 2
max_parallel_workers = 4
max_parallel_maintenance_workers = 2

# -----------------------------------------------------------------------------
# LOGGING (debug, à réduire en prod)
# -----------------------------------------------------------------------------
log_destination = 'stderr'
logging_collector = off

# Log des requêtes lentes (> 1 seconde)
log_min_duration_statement = 1000

# Log des locks
log_lock_waits = on

# Log des checkpoints
log_checkpoints = on

# -----------------------------------------------------------------------------
# LOCALE & ENCODING
# -----------------------------------------------------------------------------
# UTF8 pour support complet français/international
lc_messages = 'en_US.utf8'
lc_monetary = 'en_US.utf8'
lc_numeric = 'en_US.utf8'
lc_time = 'en_US.utf8'

# -----------------------------------------------------------------------------
# CONNEXIONS RÉSEAU
# -----------------------------------------------------------------------------
listen_addresses = '*'
port = 5432

# TCP keepalive pour détecter les connexions mortes
tcp_keepalives_idle = 60
tcp_keepalives_interval = 10
tcp_keepalives_count = 6
